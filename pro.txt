addcmd({
	Name = "visualize",
	Aliases = {"vis", "halo"},
	Function = function(sender, targets, args)
		if #targets == 0 then targets = {sender} end

		for _, plr in ipairs(targets) do
			local char = plr.Character
			if not char or not char:FindFirstChild("HumanoidRootPart") then continue end

			local vis = {
				parts = {},
				angle = 0,
				amount = 30,
				radius = 10,
				orbiter = plr,
				modes = {}
			}

			local function getxz(a, r)
				return math.cos(a) * r, math.sin(a) * r
			end

			local function hsvColor(t)
				local h = (tick() * 0.5 + t) % 1
				return Color3.fromHSV(h, 1, 1)
			end

			local function movepart(part, cf)
				part.CFrame = cf
			end

			-- Create parts
			for i = 1, vis.amount do
				local part = Instance.new("Part")
				part.Shape = Enum.PartType.Ball
				part.Size = Vector3.new(2, 2, 2)
				part.Material = Enum.Material.Neon
				part.Anchored = true
				part.CanCollide = false
				part.Color = hsvColor(i * 0.1)
				part.Parent = workspace
				table.insert(vis.parts, part)
			end

			-- Mode definitions (from your modes)
			vis.modes[1] = function()
				for i, v in pairs(vis.parts) do
					if not v or not v.Parent then return end
					coroutine.wrap(function()
						local angle = i * ((2 * math.pi) / #vis.parts) + vis.angle
						local x, z = getxz(angle, vis.radius)
						local cf = (char.HumanoidRootPart.CFrame * CFrame.new(x, 0, z)).p
						local look = char.HumanoidRootPart.Position
						movepart(v, CFrame.new(cf, look))
					end)()
				end
			end

			vis.modes[2] = function()
				local t = os.clock()
				for i, v in pairs(vis.parts) do
					if not v or not v.Parent then return end
					coroutine.wrap(function()
						local ci = math.floor(i / (vis.amount / 2))
						local angle = (i % (vis.amount / 2)) * ((2 * math.pi) / (vis.amount / 2)) + vis.angle
						local x, z = getxz(angle, vis.radius)
						local y = math.sin(t + (i * 0.2)) * 5 + ci * 4
						local cf = (char.HumanoidRootPart.CFrame * CFrame.new(x, y, z)).p
						movepart(v, CFrame.new(cf, char.HumanoidRootPart.Position))
					end)()
				end
			end

			vis.modes[3] = function()
				for i, v in pairs(vis.parts) do
					if not v or not v.Parent then return end
					coroutine.wrap(function()
						local angle = i * ((2 * math.pi) / #vis.parts) + vis.angle
						local x, z = getxz(angle, vis.radius)
						local y = math.sin(os.clock() * 2 + i) * 2
						local cf = (char.HumanoidRootPart.CFrame * CFrame.new(x, y, z)).p
						movepart(v, CFrame.new(cf, char.HumanoidRootPart.Position))
					end)()
				end
			end

			vis.modes[4] = function()
				for i, v in pairs(vis.parts) do
					if not v or not v.Parent then return end
					coroutine.wrap(function()
						local angle = i * ((2 * math.pi) / #vis.parts) + vis.angle
						local x, z = getxz(angle, vis.radius)
						local y = math.sin(os.clock() * 2 + i) * 5
						local rot = math.cos(os.clock() * 2 + i) * 0.5
						local cf = (char.HumanoidRootPart.CFrame * CFrame.new(x, y, z) * CFrame.Angles(0, rot, 0)).p
						movepart(v, CFrame.new(cf, char.HumanoidRootPart.Position))
					end)()
				end
			end

			vis.modes[5] = function()
				local num = 15
				local radius = 10
				for i = 1, num do
					coroutine.wrap(function()
						local angle = i * ((2 * math.pi) / num) + vis.angle
						local x, z = getxz(angle, radius)
						local cf = (char.HumanoidRootPart.CFrame * CFrame.new(x, 5, z)).p
						movepart(vis.parts[i], CFrame.new(cf, char.HumanoidRootPart.Position))
					end)()
				end
			end

			vis.modes[6] = function()
				local spirals = 3
				local maxR = 20
				local minR = 5
				local ppS = math.ceil(vis.amount / spirals)

				for i, v in pairs(vis.parts) do
					if not v or not v.Parent then return end
					coroutine.wrap(function()
						local spi = math.floor((i - 1) / ppS) + 1
						local pi = (i - 1) % ppS
						local angle = pi * ((2 * math.pi) / ppS) + vis.angle
						local radius = math.clamp((pi / ppS) * maxR, minR, maxR)
						local y = math.sin(vis.angle + pi) * 3
						local spiralOffset = (spi - 1) * ((2 * math.pi) / spirals)
						local x, z = getxz(angle + spiralOffset, radius)
						local cf = (char.HumanoidRootPart.CFrame * CFrame.new(x, y, z)).p
						movepart(v, CFrame.new(cf, char.HumanoidRootPart.Position))
					end)()
				end
			end

			-- Animate parts smoothly
			coroutine.wrap(function()
				local mode = tonumber(args[1]) or 1
				while plr and plr.Parent and char and char:FindFirstChild("HumanoidRootPart") do
					vis.angle += math.rad(2)
					for i, part in ipairs(vis.parts) do
						part.Color = hsvColor(i * 0.1)
					end
					if vis.modes[mode] then
						vis.modes[mode]()
					end
					game:GetService("RunService").Heartbeat:Wait()
				end

				-- Cleanup on exit/death
				for _, part in ipairs(vis.parts) do
					if part and part.Parent then part:Destroy() end
				end
			end)()
		end
	end
})
